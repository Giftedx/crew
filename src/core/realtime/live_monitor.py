"""
Live content monitoring system for the Ultimate Discord Intelligence Bot.

Provides real-time monitoring of live content streams with intelligent
content detection, trend analysis, and automated response capabilities.
"""

import asyncio
import contextlib
import logging
import time
from collections.abc import Callable
from dataclasses import dataclass, field
from enum import Enum
from typing import Any


logger = logging.getLogger(__name__)


class MonitorType(Enum):
    """Types of live monitoring."""

    KEYWORD_DETECTION = "keyword_detection"
    SENTIMENT_MONITORING = "sentiment_monitoring"
    FACT_CHECK_ALERTS = "fact_check_alerts"
    TREND_DETECTION = "trend_detection"
    QUALITY_MONITORING = "quality_monitoring"
    PERFORMANCE_MONITORING = "performance_monitoring"
    CONTENT_MODERATION = "content_moderation"
    AUDIENCE_ENGAGEMENT = "audience_engagement"


class AlertLevel(Enum):
    """Alert severity levels."""

    INFO = "info"
    WARNING = "warning"
    CRITICAL = "critical"
    EMERGENCY = "emergency"


class TrendDirection(Enum):
    """Trend direction indicators."""

    RISING = "rising"
    FALLING = "falling"
    STABLE = "stable"
    VOLATILE = "volatile"


@dataclass
class MonitoringRule:
    """Rule for live content monitoring."""

    rule_id: str
    monitor_type: MonitorType
    name: str
    description: str
    condition: str
    threshold: float
    alert_level: AlertLevel
    enabled: bool = True
    cooldown_seconds: int = 60
    metadata: dict[str, Any] = field(default_factory=dict)

    @property
    def is_active(self) -> bool:
        """Check if rule is active."""
        return self.enabled

    @property
    def is_critical_alert(self) -> bool:
        """Check if rule generates critical alerts."""
        return self.alert_level in {AlertLevel.CRITICAL, AlertLevel.EMERGENCY}


@dataclass
class MonitoringAlert:
    """Alert generated by monitoring system."""

    alert_id: str
    rule_id: str
    stream_id: str
    alert_level: AlertLevel
    message: str
    timestamp: float
    value: float
    threshold: float
    metadata: dict[str, Any] = field(default_factory=dict)
    acknowledged: bool = False
    resolved: bool = False

    @property
    def is_active(self) -> bool:
        """Check if alert is active."""
        return not self.resolved

    @property
    def age_seconds(self) -> float:
        """Get alert age in seconds."""
        return time.time() - self.timestamp

    @property
    def is_stale(self) -> bool:
        """Check if alert is stale (> 1 hour)."""
        return self.age_seconds > 3600


@dataclass
class TrendData:
    """Trend analysis data."""

    metric_name: str
    current_value: float
    previous_value: float
    trend_direction: TrendDirection
    change_percentage: float
    confidence: float
    data_points: list[tuple[float, float]] = field(default_factory=list)  # (timestamp, value)
    metadata: dict[str, Any] = field(default_factory=dict)

    @property
    def is_significant_change(self) -> bool:
        """Check if change is significant (> 10%)."""
        return abs(self.change_percentage) > 10.0

    @property
    def is_rising_trend(self) -> bool:
        """Check if trend is rising."""
        return self.trend_direction == TrendDirection.RISING

    @property
    def is_falling_trend(self) -> bool:
        """Check if trend is falling."""
        return self.trend_direction == TrendDirection.FALLING


@dataclass
class LiveContentMetrics:
    """Metrics for live content monitoring."""

    stream_id: str
    timestamp: float
    viewer_count: int = 0
    engagement_rate: float = 0.0
    sentiment_score: float = 0.0
    content_quality: float = 0.0
    fact_check_accuracy: float = 0.0
    moderation_flags: int = 0
    performance_score: float = 0.0
    metadata: dict[str, Any] = field(default_factory=dict)

    @property
    def is_high_engagement(self) -> bool:
        """Check if engagement is high."""
        return self.engagement_rate > 0.7

    @property
    def is_positive_sentiment(self) -> bool:
        """Check if sentiment is positive."""
        return self.sentiment_score > 0.5

    @property
    def is_high_quality(self) -> bool:
        """Check if content quality is high."""
        return self.content_quality > 0.8

    @property
    def has_moderation_issues(self) -> bool:
        """Check if there are moderation issues."""
        return self.moderation_flags > 0


class LiveMonitor:
    """
    Real-time live content monitoring system.

    Monitors live content streams for various metrics, trends, and conditions,
    generating alerts and providing real-time insights for content management.
    """

    def __init__(self, config: dict[str, Any] | None = None):
        """Initialize live monitor."""
        self.config = config or {}
        self.monitoring_rules: dict[str, MonitoringRule] = {}
        self.active_alerts: dict[str, MonitoringAlert] = {}
        self.trend_data: dict[str, TrendData] = {}
        self.content_metrics: dict[str, list[LiveContentMetrics]] = {}
        self.alert_callbacks: list[callable] = []
        self.monitoring_tasks: dict[str, asyncio.Task[None]] = {}
        self._shutdown_event = asyncio.Event()
        self._cooldown_timers: dict[str, float] = {}

        logger.info("Live monitor initialized")

    def add_monitoring_rule(self, rule: MonitoringRule) -> None:
        """Add a monitoring rule."""
        self.monitoring_rules[rule.rule_id] = rule
        logger.info(f"Added monitoring rule: {rule.name}")

    def remove_monitoring_rule(self, rule_id: str) -> bool:
        """Remove a monitoring rule."""
        if rule_id in self.monitoring_rules:
            del self.monitoring_rules[rule_id]
            logger.info(f"Removed monitoring rule: {rule_id}")
            return True
        return False

    def add_alert_callback(self, callback: Callable[[MonitoringAlert], None]) -> None:
        """Add a callback for alert notifications."""
        self.alert_callbacks.append(callback)
        logger.info("Added alert callback")

    async def start_monitoring(self, stream_id: str) -> None:
        """Start monitoring a stream."""
        if stream_id in self.monitoring_tasks:
            logger.warning(f"Already monitoring stream {stream_id}")
            return

        task = asyncio.create_task(self._monitor_stream(stream_id))
        self.monitoring_tasks[stream_id] = task
        self.content_metrics[stream_id] = []

        logger.info(f"Started monitoring stream {stream_id}")

    async def stop_monitoring(self, stream_id: str) -> None:
        """Stop monitoring a stream."""
        if stream_id not in self.monitoring_tasks:
            return

        task = self.monitoring_tasks[stream_id]
        task.cancel()
        with contextlib.suppress(asyncio.CancelledError):
            await task

        del self.monitoring_tasks[stream_id]
        if stream_id in self.content_metrics:
            del self.content_metrics[stream_id]

        logger.info(f"Stopped monitoring stream {stream_id}")

    async def update_metrics(self, stream_id: str, metrics: LiveContentMetrics) -> None:
        """Update metrics for a stream."""
        if stream_id not in self.content_metrics:
            self.content_metrics[stream_id] = []

        self.content_metrics[stream_id].append(metrics)

        # Keep only recent metrics (last 1000 points)
        if len(self.content_metrics[stream_id]) > 1000:
            self.content_metrics[stream_id] = self.content_metrics[stream_id][-1000:]

        # Check monitoring rules
        await self._check_monitoring_rules(stream_id, metrics)

        # Update trend data
        await self._update_trend_data(stream_id, metrics)

    async def get_active_alerts(self, stream_id: str | None = None) -> list[MonitoringAlert]:
        """Get active alerts for a stream or all streams."""
        if stream_id:
            return [alert for alert in self.active_alerts.values() if alert.stream_id == stream_id and alert.is_active]
        return [alert for alert in self.active_alerts.values() if alert.is_active]

    async def acknowledge_alert(self, alert_id: str) -> bool:
        """Acknowledge an alert."""
        if alert_id in self.active_alerts:
            self.active_alerts[alert_id].acknowledged = True
            logger.info(f"Acknowledged alert {alert_id}")
            return True
        return False

    async def resolve_alert(self, alert_id: str) -> bool:
        """Resolve an alert."""
        if alert_id in self.active_alerts:
            self.active_alerts[alert_id].resolved = True
            logger.info(f"Resolved alert {alert_id}")
            return True
        return False

    async def get_trend_analysis(self, stream_id: str, metric_name: str) -> TrendData | None:
        """Get trend analysis for a metric."""
        key = f"{stream_id}:{metric_name}"
        return self.trend_data.get(key)

    async def get_stream_metrics(self, stream_id: str, limit: int = 100) -> list[LiveContentMetrics]:
        """Get recent metrics for a stream."""
        metrics = self.content_metrics.get(stream_id, [])
        return metrics[-limit:] if limit > 0 else metrics

    async def _monitor_stream(self, stream_id: str) -> None:
        """Monitor a stream continuously."""
        logger.info(f"Starting continuous monitoring for stream {stream_id}")

        try:
            while not self._shutdown_event.is_set():
                if stream_id not in self.monitoring_tasks:
                    break

                # Simulate monitoring activities
                await self._perform_health_checks(stream_id)
                await self._cleanup_old_data(stream_id)

                await asyncio.sleep(1.0)  # Check every second

        except asyncio.CancelledError:
            logger.info(f"Monitoring cancelled for stream {stream_id}")
        except Exception as e:
            logger.error(f"Error monitoring stream {stream_id}: {e}")
        finally:
            logger.info(f"Monitoring ended for stream {stream_id}")

    async def _check_monitoring_rules(self, stream_id: str, metrics: LiveContentMetrics) -> None:
        """Check monitoring rules against current metrics."""
        for rule in self.monitoring_rules.values():
            if not rule.is_active:
                continue

            # Check cooldown
            cooldown_key = f"{stream_id}:{rule.rule_id}"
            if cooldown_key in self._cooldown_timers and (
                time.time() - self._cooldown_timers[cooldown_key] < rule.cooldown_seconds
            ):
                continue

            # Evaluate rule condition
            if await self._evaluate_rule(rule, metrics):
                await self._trigger_alert(stream_id, rule, metrics)

    async def _evaluate_rule(self, rule: MonitoringRule, metrics: LiveContentMetrics) -> bool:
        """Evaluate a monitoring rule against metrics."""
        try:
            # Simple rule evaluation (in real implementation, would use more sophisticated evaluation)
            if rule.monitor_type == MonitorType.SENTIMENT_MONITORING:
                return metrics.sentiment_score < rule.threshold
            elif rule.monitor_type == MonitorType.QUALITY_MONITORING:
                return metrics.content_quality < rule.threshold
            elif rule.monitor_type == MonitorType.PERFORMANCE_MONITORING:
                return metrics.performance_score < rule.threshold
            elif rule.monitor_type == MonitorType.CONTENT_MODERATION:
                return metrics.moderation_flags > rule.threshold
            elif rule.monitor_type == MonitorType.AUDIENCE_ENGAGEMENT:
                return metrics.engagement_rate < rule.threshold
            else:
                return False
        except Exception as e:
            logger.error(f"Error evaluating rule {rule.rule_id}: {e}")
            return False

    async def _trigger_alert(self, stream_id: str, rule: MonitoringRule, metrics: LiveContentMetrics) -> None:
        """Trigger an alert for a rule violation."""
        alert_id = f"{stream_id}:{rule.rule_id}:{int(time.time())}"
        current_value = self._get_metric_value(rule.monitor_type, metrics)

        alert = MonitoringAlert(
            alert_id=alert_id,
            rule_id=rule.rule_id,
            stream_id=stream_id,
            alert_level=rule.alert_level,
            message=f"{rule.name}: {rule.description}",
            timestamp=time.time(),
            value=current_value,
            threshold=rule.threshold,
            metadata={"rule_name": rule.name, "metrics": metrics.__dict__},
        )

        self.active_alerts[alert_id] = alert

        # Set cooldown
        cooldown_key = f"{stream_id}:{rule.rule_id}"
        self._cooldown_timers[cooldown_key] = time.time()

        # Notify callbacks
        for callback in self.alert_callbacks:
            try:
                callback(alert)
            except Exception as e:
                logger.error(f"Error in alert callback: {e}")

        logger.warning(f"Triggered alert {alert_id}: {alert.message}")

    def _get_metric_value(self, monitor_type: MonitorType, metrics: LiveContentMetrics) -> float:
        """Get the relevant metric value for a monitor type."""
        if monitor_type == MonitorType.SENTIMENT_MONITORING:
            return metrics.sentiment_score
        elif monitor_type == MonitorType.QUALITY_MONITORING:
            return metrics.content_quality
        elif monitor_type == MonitorType.PERFORMANCE_MONITORING:
            return metrics.performance_score
        elif monitor_type == MonitorType.CONTENT_MODERATION:
            return float(metrics.moderation_flags)
        elif monitor_type == MonitorType.AUDIENCE_ENGAGEMENT:
            return metrics.engagement_rate
        else:
            return 0.0

    async def _update_trend_data(self, stream_id: str, metrics: LiveContentMetrics) -> None:
        """Update trend data for metrics."""
        metric_names = [
            "viewer_count",
            "engagement_rate",
            "sentiment_score",
            "content_quality",
            "performance_score",
        ]

        for metric_name in metric_names:
            key = f"{stream_id}:{metric_name}"
            current_value = getattr(metrics, metric_name)

            if key in self.trend_data:
                trend = self.trend_data[key]
                trend.previous_value = trend.current_value
                trend.current_value = current_value
                trend.data_points.append((metrics.timestamp, current_value))

                # Keep only recent data points (last 100)
                if len(trend.data_points) > 100:
                    trend.data_points = trend.data_points[-100:]

                # Calculate trend direction
                if trend.previous_value > 0:
                    change_percentage = ((current_value - trend.previous_value) / trend.previous_value) * 100
                    trend.change_percentage = change_percentage

                    if change_percentage > 5:
                        trend.trend_direction = TrendDirection.RISING
                    elif change_percentage < -5:
                        trend.trend_direction = TrendDirection.FALLING
                    elif abs(change_percentage) < 2:
                        trend.trend_direction = TrendDirection.STABLE
                    else:
                        trend.trend_direction = TrendDirection.VOLATILE

                trend.confidence = 0.8  # Simulated confidence
            else:
                # Create new trend data
                trend = TrendData(
                    metric_name=metric_name,
                    current_value=current_value,
                    previous_value=current_value,
                    trend_direction=TrendDirection.STABLE,
                    change_percentage=0.0,
                    confidence=0.5,
                    data_points=[(metrics.timestamp, current_value)],
                )
                self.trend_data[key] = trend

    async def _perform_health_checks(self, stream_id: str) -> None:
        """Perform health checks on monitored streams."""
        # Simulate health checks
        if stream_id in self.content_metrics:
            metrics_list = self.content_metrics[stream_id]
            if len(metrics_list) > 10:
                recent_metrics = metrics_list[-10:]
                avg_quality = sum(m.content_quality for m in recent_metrics) / len(recent_metrics)
                if avg_quality < 0.5:
                    logger.warning(f"Low content quality detected for stream {stream_id}")

    async def _cleanup_old_data(self, stream_id: str) -> None:
        """Clean up old data and resolved alerts."""
        # Remove stale alerts
        stale_alerts = [alert_id for alert_id, alert in self.active_alerts.items() if alert.is_stale and alert.resolved]
        for alert_id in stale_alerts:
            del self.active_alerts[alert_id]

        # Clean up old metrics (keep last 1000)
        if stream_id in self.content_metrics:
            metrics_list = self.content_metrics[stream_id]
            if len(metrics_list) > 1000:
                self.content_metrics[stream_id] = metrics_list[-1000:]

    async def get_monitoring_statistics(self) -> dict[str, Any]:
        """Get monitoring statistics."""
        return {
            "active_rules": len([r for r in self.monitoring_rules.values() if r.is_active]),
            "total_rules": len(self.monitoring_rules),
            "active_alerts": len([a for a in self.active_alerts.values() if a.is_active]),
            "total_alerts": len(self.active_alerts),
            "monitored_streams": len(self.monitoring_tasks),
            "trend_data_points": len(self.trend_data),
            "total_metrics": sum(len(metrics) for metrics in self.content_metrics.values()),
        }

    async def shutdown(self) -> None:
        """Shutdown the live monitor."""
        logger.info("Shutting down live monitor...")

        # Signal shutdown
        self._shutdown_event.set()

        # Stop all monitoring tasks
        for stream_id in list(self.monitoring_tasks.keys()):
            await self.stop_monitoring(stream_id)

        logger.info("Live monitor shutdown complete")

    async def __aenter__(self) -> "LiveMonitor":
        """Async context manager entry."""
        return self

    async def __aexit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None:
        """Async context manager exit."""
        await self.shutdown()


# Global monitor instance
_global_monitor: LiveMonitor | None = None


def get_global_live_monitor() -> LiveMonitor:
    """Get the global live monitor instance."""
    global _global_monitor
    if _global_monitor is None:
        _global_monitor = LiveMonitor()
    return _global_monitor


def set_global_live_monitor(monitor: LiveMonitor) -> None:
    """Set the global live monitor instance."""
    global _global_monitor
    _global_monitor = monitor


# Convenience functions for global monitor
async def add_monitoring_rule(rule: MonitoringRule) -> None:
    """Add a monitoring rule using the global monitor."""
    return get_global_live_monitor().add_monitoring_rule(rule)


async def start_monitoring(stream_id: str) -> None:
    """Start monitoring using the global monitor."""
    return await get_global_live_monitor().start_monitoring(stream_id)


async def update_metrics(stream_id: str, metrics: LiveContentMetrics) -> None:
    """Update metrics using the global monitor."""
    return await get_global_live_monitor().update_metrics(stream_id, metrics)


async def get_active_alerts(stream_id: str | None = None) -> list[MonitoringAlert]:
    """Get active alerts using the global monitor."""
    return await get_global_live_monitor().get_active_alerts(stream_id)
