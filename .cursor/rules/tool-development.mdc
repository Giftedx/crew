---
globs: src/ultimate_discord_intelligence_bot/tools/*.py,**/tools/*.py
---
# Tool Development Patterns - Ultimate Discord Intelligence Bot

## CrewAI Tool Template

All tools must follow this pattern:

```python
from __future__ import annotations

from typing import Type

from crewai_tools import BaseTool
from pydantic import BaseModel, Field

from ultimate_discord_intelligence_bot.step_result import StepResult


class MyToolInput(BaseModel):
    """Input schema for MyTool."""

    content: str = Field(..., description="Content to process")
    tenant: str = Field(..., description="Tenant identifier")
    workspace: str = Field(..., description="Workspace identifier")


class MyTool(BaseTool):
    """Tool for processing X with Y capabilities."""

    name: str = "my_tool"
    description: str = "Processes content by doing X, Y, and Z"
    args_schema: Type[BaseModel] = MyToolInput

    def _run(self, content: str, tenant: str, workspace: str) -> StepResult:
        """Execute the tool logic.

        Args:
            content: Content to process
            tenant: Tenant identifier for isolation
            workspace: Workspace identifier

        Returns:
            StepResult with processed data or error
        """
        try:
            # Validate inputs
            if not content:
                return StepResult.fail("Content cannot be empty")

            # Tool logic here
            result = self._process_content(content)

            # Return success
            return StepResult.ok(data={
                "processed": result,
                "tenant": tenant,
                "workspace": workspace
            })

        except ValueError as e:
            return StepResult.bad_request(str(e))
        except Exception as e:
            return StepResult.fail(f"Processing failed: {str(e)}")

    def _process_content(self, content: str) -> dict:
        """Internal processing logic."""
        # Implementation here
        return {"result": content.upper()}
```

## Tool Design Requirements

### 1. Input Validation

Always validate inputs before processing:

```python
def _run(self, url: str, tenant: str, workspace: str) -> StepResult:
    # Type validation
    if not isinstance(url, str):
        return StepResult.bad_request("URL must be a string")

    # Business logic validation
    if not url.startswith(("http://", "https://")):
        return StepResult.bad_request("Invalid URL format")

    # Tenant validation
    if not tenant or not workspace:
        return StepResult.bad_request("Tenant and workspace required")
```

### 2. Error Handling Hierarchy

Use appropriate StepResult methods:

```python
# User input errors
return StepResult.bad_request("Invalid input format")

# Resource not found
return StepResult.fail("Content not found", status="not_found")

# Rate limiting
return StepResult.fail("Rate limit exceeded", status="rate_limited")

# General errors
return StepResult.fail(f"Processing failed: {str(e)}")

# Success with data
return StepResult.ok(data={"result": processed_data})
```

### 3. Tenant Isolation

Always use tenant context for data operations:

```python
def _run(self, content: str, tenant: str, workspace: str) -> StepResult:
    # Create namespace for tenant isolation
    namespace = f"{tenant}:{workspace}"

    # Use namespace in all storage operations
    collection_name = f"vectors_{namespace}"

    # Pass tenant context to services
    result = self.memory_service.store(
        content=content,
        tenant=tenant,
        workspace=workspace
    )
```

### 4. Service Integration

Use dependency injection for services:

```python
class AnalysisTool(BaseTool):
    """Tool with service dependencies."""

    def __init__(self):
        super().__init__()
        self.memory_service = MemoryService()
        self.prompt_engine = PromptEngine()
        self.openrouter = OpenRouterService()

    def _run(self, content: str, tenant: str, workspace: str) -> StepResult:
        # Use services
        prompt = self.prompt_engine.create_prompt("analysis", content=content)
        response = self.openrouter.complete(prompt)
```

## Tool Categories

### Content Ingestion Tools

- Handle multi-platform content
- Validate URLs and formats
- Extract metadata
- Return structured content

### Analysis Tools

- Process transcripts and text
- Use LLM services appropriately
- Structure outputs consistently
- Include confidence scores

### Memory Tools

- Store with tenant isolation
- Include proper metadata
- Support semantic search
- Handle embeddings correctly

### Discord Integration Tools

- Format for Discord limits
- Handle rate limiting
- Support rich embeds
- Manage attachments

## Tool Registration

Register tools in [crew.py](mdc:src/ultimate_discord_intelligence_bot/crew.py):

```python
def kickoff(self, inputs):
    """Execute the crew with proper tool registration."""
    # Register tools to agents
    debate_analyst = self.agents.debate_analyst()
    debate_analyst.tools = [
        ContentIngestionTool(),
        DebateAnalysisTool(),
        FactCheckingTool(),
    ]
```

## Performance Considerations

### 1. Streaming Support

For large content processing:

```python
def _run(self, url: str, tenant: str, workspace: str) -> StepResult:
    try:
        # Stream large files
        with requests.get(url, stream=True) as response:
            for chunk in response.iter_content(chunk_size=8192):
                self._process_chunk(chunk)
    except Exception as e:
        return StepResult.fail(f"Streaming failed: {str(e)}")
```

### 2. Caching

Use caching for expensive operations:

```python
from functools import lru_cache

@lru_cache(maxsize=100)
def _get_cached_analysis(self, content_hash: str) -> dict:
    """Cache analysis results by content hash."""
    return self._perform_analysis(content_hash)
```

### 3. Rate Limiting

Respect external API limits:

```python
from tenacity import retry, stop_after_attempt, wait_exponential

@retry(
    stop=stop_after_attempt(3),
    wait=wait_exponential(multiplier=1, min=4, max=10)
)
def _call_external_api(self, data: dict) -> dict:
    """Call external API with retry logic."""
    return self.api_client.process(data)
```

## Testing Tools

Every tool needs comprehensive tests:

```python
def test_tool_success():
    """Test successful tool execution."""
    tool = MyTool()
    result = tool._run("test content", "tenant1", "workspace1")

    assert result.status == "success"
    assert result.data["processed"] is not None

def test_tool_validation():
    """Test input validation."""
    tool = MyTool()
    result = tool._run("", "tenant1", "workspace1")

    assert result.status == "bad_request"
    assert "empty" in result.error.lower()
```
