---
alwaysApply: false
description: Startup and validation patterns for application initialization and deployment
---
# Startup and Validation Patterns

## Application Startup Standards

All applications must follow this startup validation pattern established in [start_bot.py](mdc:start_bot.py):

### Environment Validation

```python
def check_environment() -> bool:
    """Check if required environment variables are set."""
    load_dotenv()

    required_vars = {
        "DISCORD_BOT_TOKEN": "Discord bot token",
        "OPENAI_API_KEY": "OpenAI API key (or OPENROUTER_API_KEY)",
        "QDRANT_URL": "Qdrant vector database URL",
    }

    missing = []
    for var, description in required_vars.items():
        # Handle alternative API keys
        if var == "OPENAI_API_KEY":
            if not (os.getenv("OPENAI_API_KEY") or os.getenv("OPENROUTER_API_KEY")):
                missing.append(f"{var} (or OPENROUTER_API_KEY): {description}")
        elif not os.getenv(var):
            missing.append(f"{var}: {description}")

    if missing:
        print("‚ùå Missing required environment variables:")
        for var in missing:
            print(f"   - {var}")
        return False

    return True
```

### Service Connectivity Validation

```python
def validate_services() -> bool:
    """Validate connectivity to external services."""

    # Test Qdrant connection
    try:
        from qdrant_client import QdrantClient
        client = QdrantClient(url=os.getenv("QDRANT_URL"))
        collections = client.get_collections()
        print("‚úÖ Qdrant connection successful")
    except Exception as e:
        print(f"‚ùå Qdrant connection failed: {e}")
        return False

    # Test Discord token
    try:
        import discord
        # Basic token format validation
        token = os.getenv("DISCORD_BOT_TOKEN")
        if not token or not token.startswith(("Bot ", "MTk", "Nz")):
            print("‚ùå Invalid Discord bot token format")
            return False
        print("‚úÖ Discord token format valid")
    except Exception as e:
        print(f"‚ùå Discord validation failed: {e}")
        return False

    return True
```

### Graceful Startup Process

```python
async def main():
    """Main entry point with comprehensive validation."""
    print("üöÄ Starting Ultimate Discord Intelligence Bot...")

    # Phase 1: Environment validation
    if not check_environment():
        print("üí° Create a .env file with required variables")
        sys.exit(1)
    print("‚úÖ Environment variables validated")

    # Phase 2: Service connectivity
    if not validate_services():
        print("üí° Check service configuration and connectivity")
        sys.exit(1)
    print("‚úÖ External services validated")

    # Phase 3: Component initialization
    try:
        bot = await create_bot()
        print("‚úÖ Bot components initialized")
    except Exception as e:
        print(f"‚ùå Component initialization failed: {e}")
        sys.exit(1)

    # Phase 4: Service startup
    try:
        token = os.getenv("DISCORD_BOT_TOKEN")
        await bot.start(token)
    except discord.LoginFailure:
        print("‚ùå Discord authentication failed")
        sys.exit(1)
    except Exception as e:
        print(f"‚ùå Service startup failed: {e}")
        sys.exit(1)
```

## Deployment Script Standards

Follow the pattern established in [deploy.sh](mdc:deploy.sh) for all deployment scripts:

### Pre-deployment Validation

```bash
# Check project directory
if [ ! -f "pyproject.toml" ]; then
    echo "‚ùå Error: Run this script from the project root directory"
    exit 1
fi

# Validate virtual environment
if [ ! -d "venv" ]; then
    echo "‚ùå Error: Virtual environment not found"
    exit 1
fi

# Check environment file
if [ ! -f ".env" ]; then
    echo "‚ö†Ô∏è  No .env file found"
    echo "üí° Please copy .env.example to .env and configure your API keys"
    exit 1
fi
```

### Dependency Verification

```bash
# Check if dependencies are installed
if ! python -c "import crewai, discord, qdrant_client" 2>/dev/null; then
    echo "‚ö†Ô∏è  Installing dependencies..."
    pip install -e .
    echo "‚úÖ Dependencies installed"
else
    echo "‚úÖ Dependencies already satisfied"
fi
```

### Service Health Validation

```bash
# Test external service connectivity
if [ "$QDRANT_URL" != ":memory:" ]; then
    if python -c "
from qdrant_client import QdrantClient
client = QdrantClient(url='$QDRANT_URL')
collections = client.get_collections()
print('‚úÖ Qdrant connection successful')
"; then
        echo "‚úÖ Qdrant connection verified"
    else
        echo "‚ùå Qdrant connection failed"
        exit 1
    fi
fi
```

## Error Handling in Startup

### Informative Error Messages

```python
# BAD - Generic error
except Exception as e:
    print(f"Error: {e}")
    sys.exit(1)

# GOOD - Specific, actionable error
except discord.LoginFailure:
    print("‚ùå Invalid Discord bot token")
    print("üí° Check your DISCORD_BOT_TOKEN in .env file")
    print("   Get a new token at: https://discord.com/developers/applications")
    sys.exit(1)
```

### Exit Code Standards

```python
# Standard exit codes
sys.exit(0)   # Success
sys.exit(1)   # General error
sys.exit(2)   # Misuse of shell command
sys.exit(126) # Command cannot execute
sys.exit(127) # Command not found
sys.exit(130) # Script terminated by Ctrl+C
```

## Component Initialization Order

Always initialize components in this order:

1. **Environment Loading** - Load .env files first
2. **Logging Setup** - Configure logging early for debugging
3. **Settings Validation** - Check all required configuration
4. **External Services** - Validate connectivity to databases, APIs
5. **Core Components** - Initialize business logic components
6. **Service Startup** - Start network services last

```python
def initialize_application():
    # 1. Load environment
    load_dotenv()

    # 2. Setup logging
    setup_logging()

    # 3. Validate settings
    if not validate_configuration():
        raise StartupError("Configuration validation failed")

    # 4. Test external services
    if not test_external_services():
        raise StartupError("External service validation failed")

    # 5. Initialize core components
    crew = UltimateDiscordIntelligenceBotCrew()

    # 6. Return ready application
    return create_application(crew)
```

## Docker Container Startup

### Multi-stage Health Checks

```dockerfile
# Health check with startup period
HEALTHCHECK --interval=30s --timeout=10s --start-period=40s --retries=3 \
    CMD python -c "import requests; requests.get('http://localhost:8000/health')" || exit 1
```

### Graceful Shutdown

```python
import signal

def signal_handler(sig, frame):
    print('üõë Shutting down gracefully...')
    # Cleanup resources
    cleanup_resources()
    sys.exit(0)

signal.signal(signal.SIGINT, signal_handler)
signal.signal(signal.SIGTERM, signal_handler)
```

## Service Dependencies

### Startup Order in Docker Compose

```yaml
services:
  bot:
    depends_on:
      qdrant:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "python", "-c", "import discord; print('healthy')"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
```

### Retry Logic for External Services

```python
from tenacity import retry, stop_after_attempt, wait_exponential

@retry(
    stop=stop_after_attempt(5),
    wait=wait_exponential(multiplier=1, min=4, max=10)
)
def connect_to_service():
    """Connect with exponential backoff."""
    client = ServiceClient(url=service_url)
    client.health_check()
    return client
```

## Configuration Validation

### Schema Validation

```python
from pydantic import BaseSettings, validator

class Settings(BaseSettings):
    """Application settings with validation."""

    discord_token: str
    openai_api_key: Optional[str] = None
    openrouter_api_key: Optional[str] = None
    qdrant_url: str = ":memory:"

    @validator("discord_token")
    def validate_discord_token(cls, v):
        if not v or len(v) < 50:
            raise ValueError("Invalid Discord token")
        return v

    @validator("openrouter_api_key", always=True)
    def validate_api_keys(cls, v, values):
        if not v and not values.get("openai_api_key"):
            raise ValueError("Either OpenAI or OpenRouter API key required")
        return v
```

### Feature Flag Validation

```python
def validate_feature_flags():
    """Validate feature flag configuration."""
    flags = {
        "ENABLE_DEBATE_ANALYSIS": bool,
        "ENABLE_FACT_CHECKING": bool,
        "ENABLE_MEMORY_STORAGE": bool,
    }

    for flag, expected_type in flags.items():
        value = os.getenv(flag, "").lower()
        if value and value not in ["true", "false", "1", "0"]:
            raise ValueError(f"Invalid value for {flag}: {value}")
```

## Logging During Startup

### Structured Startup Logging

```python
import logging
import structlog

def setup_logging():
    """Configure structured logging for startup."""
    structlog.configure(
        processors=[
            structlog.stdlib.filter_by_level,
            structlog.stdlib.add_logger_name,
            structlog.stdlib.add_log_level,
            structlog.stdlib.PositionalArgumentsFormatter(),
            structlog.processors.TimeStamper(fmt="iso"),
            structlog.processors.StackInfoRenderer(),
            structlog.processors.format_exc_info,
            structlog.dev.ConsoleRenderer()
        ],
        context_class=dict,
        logger_factory=structlog.stdlib.LoggerFactory(),
        cache_logger_on_first_use=True,
    )

logger = structlog.get_logger()

def startup_with_logging():
    """Startup with detailed logging."""
    logger.info("application_startup_initiated", version="1.0.0")

    try:
        # Validation steps
        logger.info("validating_environment")
        check_environment()

        logger.info("connecting_to_services")
        validate_services()

        logger.info("initializing_components")
        initialize_components()

        logger.info("application_startup_complete")
    except Exception as e:
        logger.error("startup_failed", error=str(e), exc_info=True)
        raise
```
